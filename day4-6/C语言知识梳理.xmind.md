# C语言知识梳理

## 基础

### 注释

#### c风格 /*   */

#### C++  //

### 字符串

#### 双引号引起来的一串字符 “ ”，单引号 ‘ ’的叫字符

#### 转义字符

##### 三字母词

###### ??( -> [

###### ??) ->]

###### ??< -> {

###### ??> -> }

##### \?

##### \'

##### \n

##### \b

##### \r

##### ...

### 数据类型

#### char 1 byte java 2  -2^7~2^7-1 unsigned 2^8 -1

#### short 2byte

#### int 4byte

#### long 4byte 32位机

#### long long 8 byte 32

#### float 4  3.402823e+38 ~ 1.401298e-45

#### double 8  1.797693e+308~ 4.9000000e-324

### 常量

#### 在计算机语言中不变的量叫常量

#### 枚举常量 enum

#### const 修饰的量具有常量属性

##### 拓展

### 变量

#### 计算机语言中变化的量

#### 命名规则

##### 必须以字母及下划线_ 开头 后跟字母、数字、下划线，不能有其他字符

##### 与函数名、宏定义、结构体成员名等一致，它们统称为标识(zhi)符

##### 不能与关键字同名

###### auto break case char const continue default do
double else enum extern float for goto if int
long register return short signed sizeof
static struct switch typedef union unsigned void
volatile while

####### register //寄存器关键字
typedef //类型重命名
volatile//保证内存可见性
重要的几个关键字

#### 分类

##### 局部变量

###### 出现在局部范围内的变量，函数中，代码块里{}...

###### main 函数里的变量也是局部变量，只是生命周期和全局变量相同

##### 全局变量

###### 出现在所有代码块之外的变量

##### static

###### static修饰的局部变量

####### static局部变量中文名叫静态局部变量。它与普通的局部变量比起来有如下几个区别：

           1）位置：静态局部变量被编译器放在全局存储区.data（注意：不在.bss段内，原因见3）），所以它虽然是局部的，但是在程序的整个生命周期中存在。

           2）访问权限：静态局部变量只能被其作用域内的变量或函数访问。也就是说虽然它会在程序的整个生命周期中存在，由于它是static的，它不能被其他的函数和源文件访问。

           3）值：静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0，以后每次调用静态局部变量的时候都用上次调用后的值。这个比较好理解，每次函数调用静态局部变量的时候都修改它然后离开，下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值
	不改变作用域

###### static修饰全局变量

####### 静态全局变量和其他的全局变量的存储地点并没有区别，
都是在.data段（已初始化）或者.bss段（未初始化）内，
但是它只在定义它的源文件内有效，其他源文件无法访问它

###### static 修饰函数

####### 使其只在当前源文件内可见

#### 初始化与赋值

##### 初始化 int a = 10；

##### 赋值 a = 20；

### 表达式

#### 如 ：sum = a + b；

##### 值属性： 结果

##### 类型属性 ：所产生的是 哪种类型的值，决定了值得用途

##### 隐式类型转换

###### C的整型算术运算总是⾄至少以缺省整型类型的精度来进⾏行行的。为了了获得这个精度，表达式中的字
符和短整型操作数在使⽤用之前被转换为普通整型，这种转换称为『整型提升』。

## 分支语句结构

### 语句

#### 一个分号；隔开就是一条语句

### if语句

#### if（）
	{
语句；
	}
if （）
	{
语句1；
	}
else
	{
	语句2；
	}
单挑语句可以不用{}，多条必须{}

#### if中的浮点判断，由于存在精度误差，要用范围判断

### switch 语句

#### 功能：简化if语句

#### switch语序嵌套使用

#### switch（）
{
case 整形常量：
		{
		语句；
		}
		break；
}

#### 记得加default、break（不加后面的case语句继续执行）

### goto语句（了解）

#### 可以用于循环以及跳出多层循环

## 循环语句结构

### while

#### continue

##### 跳出本次循环（跳过其后的代码）

#### break

##### 跳出循环

### for

#### for（语句；语句2；语句3）

##### 不能在循环体内修改循环变量

##### 语句2是一个判断语句，为真继续循环，为假时结束循环

#### for（；；）
死循环

### do...while

#### 不常用

### 循环效率

#### 短套长

#### 判断尽量往外放

### 折半查找

#### 前提条件：有序

#### 优点：高效

### 猜数字游戏

#### srand((unsigned)time(NULL));//设置随机数起点
rand（）；

## 操作符与表达式

### 算术操作符

#### + - *  / %

### 位移操作符

#### << 左移操作符

##### 左边抛弃，右边补0

#### >> 右移操作符

##### 逻辑右移

###### 左边补0，右边抛弃

##### 算数右移

###### 左边补符号位，右边抛弃

#### 不可移负数位，操作未定义

### 位操作符

#### & 按位与
| 按位或
^ 按位异或
操作数必须是整数

### 赋值操作符

#### +=
-=
*=
/=
%=
>>=
<<=
&=
|=
=

### 单目操作符

#### ！
-
+
&//取地址
sizeof（重点）
~ 对一个数的二进制按位取反
--
++
* 解引用
（强制转换）

#### sizeof 与strlen的区别

##### sizeof操作符，strlen是函数，strlen传递数组会发生降维

##### sizeof可用类型作参数，本身也可作为函数参数strlen只能用char*作参数

##### sizeof在编译时计算，strlen在运行时计算

##### sizeof 按字节统计

### 关系操作符

#### >
>=
<
<=
!=
==

#### == （是否等于）区别于 =（赋值）

### 逻辑操作符

#### && 逻辑与
|| 逻辑或

#### & 按位与
| 按位或

### 条件操作符

#### a ？ b：c

##### a与b关系满足返回 b，不满足 返回c

### 逗号表达式

#### 逗号表达式，从左向右依次执行。
整个表达式的结果是最后一个表达式的结果。

### 下表引用、函数调用和结构成员

#### 下标引用 ：数组

#### 函数调用 name（）；

#### 结构体 .访问
为结构体指针时：->

## 简单函数

### 什么叫函数

#### 子程序，相对于其他代码，具有独一性，能够完成特定的任务

### 库函数

#### - IO函数

#### - 字符串操作函数

#### - 字符操作函数

#### - 内存操作函数

#### - 时间/日期函数

#### - 数学函数

#### - 其他库函数

### 自定义函数

#### ret_type 返回类型

#### fun_name 函数名

#### para1 函数参数

### 形参与实参

#### 形参实例化

##### 形参实例化后相当于实参的一份临时拷贝

### 函数的设计

#### #ifndef __TEST_H__
#define __TEST_H__
//函数的声明
int Add(int x, int y);
#endif //__TEST_H__

### 链接属性

#### 1. 外部链接属性

##### 外部链接属性就意味着，一个标识符，不仅可以在当前源文件使用。使用extern 的声明可以在其他源文件使用。

#### 2. 内部链接属性

##### static 关键字修饰之后

#### 3. ⽆无链接属性

##### 局部变量

## 数组

### 1. 一维数组的创建和初始化。

#### 创建

##### type_t arr_name [const_n]
类型      名字 [大小]
int arr[10];

##### 数组创建时，大小必须是常量

#### 初始化

##### int arr[10] = {0};
char str [10] ={0};

#### 注意

##### char arr1[] = "abc";

###### 有 "\0"

##### char arr2[3] = {'a','b','c'};

###### 没有 "\0"

##### char*p = "abcdef";

###### 存放在文字常量区，不可被修改

###### 拓展：malloc等开辟的空间在堆区
程序员释放

### 2. 一维数组的使用。

#### 1.	数组是使用下标来访问的，下标是从0开始。

##### arr[2];

#### 2.	数组的⼤小可以通过计算得到。

##### sizeof(arr) -->arr类型 * 数组长度
int arr[10];
sizeof(arr) = 4*10

##### sizeof 会统计 \0

##### strlen(char*) 不统计“\0”，将其作为结束标识符

### 3. 一维数组在内存中的存储。

#### 数组在内存中是连续存放的
多维数组也是连续存放
并非是矩阵那样

### 4. 指针的初步介绍

#### 这里说的指针其实是 指针变量

#### 用来存放地址

#### 用* 对指针进行解引用

### 5. 一维数组的指针访问

#### &arr+1

##### 加上整个数组大小，即取数组名，表示整个数组的大小

#### arr+1

##### 表示首元素地址，加一表示第二个元素

### 6. 二维数组的创建和初始化。

#### 与一维数组类似

### 7. 二维数组的使用。

#### 下标访问

### 8. 二维数组在内存中的存储。

#### 可以看成一维数组，其中每个元素是一个一维数组

#### 多维数组可以看成一维数组，其中元素是一个个n-1维的数组
它们都是连续存储的

#### sizeof 字符串

##### char *p = "abcdef";

##### printf("%d\n", sizeof(p));//4

##### p里放的是“abcdef”的地址
所以是4

#### 数组名代表整个数组的时候只有两种情况：

##### sizeof(数组名)，这⾥的数组名表示整个数组。

##### &数组名，这里的数组名表示整个数组。

### 9. 二维数组的指针访问。

#### 与一位数组类似

### 10. 有关数组的运算。

#### sizeof

#### strlen

### 11. 数组作为函数参数。

#### 传函数名

### 12. 数组的应用实例1：三子棋。

### 13. 数组的应用实例2：扫雷游戏

## VS使用技巧

### 1. 什么是bug？

#### 表示电脑系统或程序隐藏错误、缺陷、漏洞或问题

### 2. 调试是什么？有多重要？

#### debug：
发现和减少bug

##### 发现程序错误的存在

##### 以隔离、消除等方式对错误进行定位

##### 确定错误产⽣的原因

##### 提出纠正错误的解决办法

##### 对程序错误予以改正，重新测试

### 3. debug和release的介绍。

#### debug：调试版本，无优化

#### release：发布版本，已经优化

### 4. windows环境调试介绍。

#### F5

##### 启动调试，经常用来直接调到下一个断点处。

#### F9

##### 创建断点和取消断点

#### F10

##### 逐过程调试

#### F11

##### 逐语句

#### CTRL + F5

##### 开始执行不调试

#### CTRL

##### 运行至某处，减少调试时间

### 5. 一些调试的实例。

#### 监视

#### 内存

#### 堆栈

#### 反汇编

### 6. 如何写出好（易于调试）的代码。

#### 1. 使用assert

#### 2. 尽量使用const

#### 3. 养成良好的编码风格

#### 4. 添加必要的注释

#### 5. 避免编码的陷阱。

### 7. 编程常⻅见的错误。

#### 1. 编译型错误

#### 2. 链接型错误

#### 3. 运⾏时错误

## 程序环境和预处理

### 1. 程序的翻译环境和执行环境

#### 预编译-E(.i)

##### 预处理指令

#### 编译-S (.s)

##### 语法分析

##### 词法分析

##### 语义分析

##### 符号分析

#### 汇编 -c (.o)

##### 形成符号表（存放变量的地址）
产生二进制文件

#### 链接

##### 合并段表
符号表的合并和符号表的重定位

###### 段表

####### 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。

####### 段表引入主要在内存中找到每个逻辑段所对应的位置，
每个段在段表都有一个表项，记录了该段在内存中的起始地址(又称为 “基址” )和段的长度。
起始地址是指逻辑地址映射到内存起始地址，段长是指段的长度，可以检查地址是否越界。

### 2. 详解编译+链接

#### 预定义符号
（宏）

##### __FILE__ //进行编译的源文件

##### __LINE__ //⽂文件当前的行号

##### __DATE__ //⽂文件被编译的日期
用%s打印

##### __TIME__ //⽂文件被编译的时间
用%s 打印

##### __STDC__ //如果编译器器遵循ANSI C，其值为1，否则未定义

### 3. 预处理理详解

#### 使用宏时，后面的 空格 是分隔符

##### 不要使用带副作用的参数，如典型的i++

#### #define 定义标识符

##### 在定义宏函数时，不要吝啬括号，在所有的编码中都不要吝啬括号

##### #define 机制包括了一个规定，允许把参数替换到⽂本中，这种实现通常称为宏（macro）或定义宏（define macro）。

#### #和##

##### 使用 # ，把一个宏参数变成对应的字符串。

##### ##可以把位于它两边的符号合成一个符号。
它允许宏定义从分离的⽂本片段创建标识符。

#### 宏和函数

##### 比如：
#define MAX(a, b) ((a)>(b)?(a):(b))

###### 和函数一样，也可以进行参数传递（a，b）

##### 相比于函数的优点

###### 速度快，没有开辟栈桢结构

###### 没类型限制

##### 劣势

###### 1. 每次使⽤宏的时候，一份宏定义的代码将插⼊到程序中。除⾮宏比较短，否则可能大幅度增加程序的长度。

###### 2. 宏是没法调试的。

###### 3. 宏由于类型⽆关，也就不够严谨。

###### 4. 宏可能会带来运算符优先级的问题，导致程容易出现错。

##### #undef

###### 移出宏定义

##### 条件编译# define __DEBUG__

###### # ifdef __DEBUG__
......
# endif / /__DEBUG__

##### 防止文件被重复引用

###### #ifndef __TEST_H__
#define __TEST_H__
//头⽂文件的内容
#endif //__TEST_H__

## 深度剖析数据在内存中的存储

### 数据类型介绍

#### 整形家族：

##### char
unsigned char
signed char
short
unsigned short [int]
signed short [int]
int
unsigned int
signed int
long
unsigned long [int]
signed long [int]

#### 浮点数家族：

##### float
double

#### 构造类型：

##### > 数组类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union

#### 指针类型

#### 空类型

##### 函数的返回类型、函数的参数（void类型函数不是没有返回值）、指针类型

### 整形在内存中的存储

#### 数据存放内存中其实存放的是补码。
因为处理器中只有加法器

### ⼤小端介绍

#### 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中

#### 小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的⾼地址中

##### 小小小

#### char a = 128;
printf("%u\n",a);//4294967168 
11111111111111111111111110000000
return 0;
这里的128 整形提升为32bit

### 浮点型在内存中的存储

#### (-1)^S * M * 2^E

#### (-1)s表示符号位，当s=0，V为正数；当s=1，V为负数。

#### M表示有效数字，大于等于1，小于2。

#### 2^E表示指数位。

#### 十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2 。那么，s=1，M=1.01，E=2

#### 对于32位的浮点数，最⾼高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。

#### 对于E，要加上一个中间数127（8位E）1023（11位E）

### C/C++程序内存的分配

#### 1、栈区（stack）—　 由编译器器⾃自动分配释放 ，存放为运⾏函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作⽅式类似于数据结构中的栈。

#### 2、堆区（heap） —　 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配⽅式类似于链表。

#### 3、全局区（静态区）（static）—存放全局变量、静态数据、常量。程序结束后由系统释放。

#### 4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放。

#### 5、程序代码区—存放函数体（类成员函数和全局函数）的二进制代码。

#### 内存分配⽅方式有三种

##### 从静态存储区域分配

###### 内存在程序编译的时候就已经分配好，这块内存在程序的整个运⾏期间都存在。例如全局变量，static变量。

##### 在栈上创建

###### 函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放

##### 从堆上分配

###### malloc或new

###### 程序员自己负责在何时用free或delete释放内存。

### const的深度讲解及volatile关键字介绍

#### volatile

##### 编译时不优化，执行时不缓存，每次需从内存中读出（保证内存的可见性）

##### ⽤用于多线程或多CPU编程

#### static

##### 如果不显示的初始化，静态变量的初始化为0，

##### ⽽自动变量是不做任何初始化的，是随机值。

##### static修饰的全局变量只能被当前源文件访问

## 深度理解函数

### 函数的调用过程（栈帧

#### 看博客

#### 临时变量就是因为存放在栈桢中，函数调用结束销毁栈桢是一并被销毁

### 函数递归

#### 自己调用自己

#### 把大事化小

#### 与递归相比

##### 递归：代码简单，性能差，不断形成栈桢

##### 递归：代码复杂，不形成战争。

### main函数的参数解析

#### int main( int argc, char *argv[ ], char *envp[ ] )

##### argc是个整型变量，表示命令行参数的个数（含第一个参数）

##### argv是个字符指针的数组，每个元素是⼀个字符指针，指向一个字符串。这些字符串就是命令行中的每一个参数（字符串）。

##### envp是字符指针的数组，数组的每一个原元素是⼀个指向⼀个环境变量（字符串）
的字符指针。

### 可变参数列表解析

#### 如：int average(int n, ...)

#### #include <stdarg.h>

##### va_list

###### va_list arg;//声明一个变量

##### va_start

###### va_start(arg, n);//初始化

##### va_arg

###### va_arg(arg, int);//用来访问参数

##### va_eng

###### va_end(arg);//结束

##### 以上都是宏实现

#### 看博客：可变参数列表实现printf

## 指针（上）

### 指针是什么？

#### 指针就是变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。

### 为什么存在指针？

#### 为了方便访问内存空间

#### 指针大小为4字节（32位机），8字节（64位机）

### 指针和指针类型

#### 指针是变量，那就有类型

##### type + *形式
如 char * 类型的指针

##### 只要有类型的区分，就定出一定的规则，使得编码会更加严谨。

##### 确定了指针运算的规律。

#### 指针+-整数

##### 指针的类型决定了指针向前或者向后走一步有多大（距离）
（元素个数）
int *的指针 加一，地址加4

### 二级指针

#### * *p
三级 ** *p
...

### 指针表达式解析

#### char ch = 'a';
char *cp = &ch;

##### &ch; //&ch是地址常量，不能做左值，但是可以做右值。

##### cp; //cp是变量 可以做左值，可以做右值

##### &cp; //&cp是地址常量，不能做左值，但是可以做右值。

##### *cp+1; //*cp+1表达式的结果是常量，不能做左值，但是可以做右值。

##### *(cp+1); //*(cp+1)表示ch之后的⼀块空间，可以做左值，也可以是右值

##### ++cp; //C语⾔中变量的前置++不能做为左值，可以是右值

##### cp++; //C语言中变量的后置++不能做为左值，可以是右值

##### *++cp; //*++cp是ch的下一块空间，可以做左值，也可以做右值

##### *cp++; //++是后置的，所有表达式*cp++可以做为左值，也可以做右值。

##### ++*cp; //表达式是对*cp的前置++，不能做左值，但是可以做右值。

##### (*cp)++; //表达式是对*cp的后置++，不能做左值，但是可以做右值。

##### ++*++cp; //表达式是对ch下一块空间内容的前置++，所有表达式不能做左值，但是可以做右值

##### ++*cp++; //表达式是对ch内容的前置++，同时对cp也进行后置++，所以表达式不不能做左值，但是可以做右值。

#### C语言中前/后置 ++ 不可为左值

### 模拟库函数

#### 模拟实现strlen

#### 模拟实现strcpy

#### 模拟实现strcat

#### 模拟实现strstr

#### 模拟实现strcmp

#### 模拟实现memcpy

#### 模拟实现memmove

#### 一定要写到会!

## 指针（下）

### 练习

#### int a[] = {1,2,3,4};

#### printf("%d\n",sizeof(a));

#### printf("%d\n",sizeof(a+0));

#### printf("%d\n",sizeof(*a));

#### printf("%d\n",sizeof(a+1));

#### printf("%d\n",sizeof(a[1]));

#### printf("%d\n",sizeof(&a));

#### printf("%d\n",sizeof(&a+1));

#### printf("%d\n",sizeof(&a[0]));

#### printf("%d\n",sizeof(&a[0]+1));

#### ......

#### 还有好多，在书上，好好看

### 这几节有博客总结

#### 指针数组

##### 不管前面定语是什么，最后两个字是****数组就在数组，*****指针就是指针

##### 指针创建时，会开辟一块空间存放指针，而数组不会单独开辟

#### 数组指针

##### 指针和数组什么关系？没有关系！！！

#### 指针和数组的定义、声明

##### char* p = "abcdef";
复习：这个是不能通过指针访问修改内容的，放在文字常量区

#### 数组参数、指针参数

#### 函数指针

#### 函数指针数组、函数指针的数组的指针

##### 转移表

### 回调函数

#### 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现⽅方直接调用，⽽是在特定的事件或条件发生时由另外的⼀方调⽤的，⽤于对该事件或条件进行响应

#### 实例：qsort

## 字符函数和字符串函数

### 求字符串长度

#### 它的返回值是一个无符号数

### 长度不受限制的字符串函数

#### strcpy

##### 覆盖内存拷贝是不可以的；

###### char str[100] = { 'a', 'c' ,'d','f'};
	char * st=strcpy(str+2,str);
	printf("%s\n%s\n", st,str);
想想结果为什么是：acdfdf，acacdfdf

#### strcat

##### 字符串拼接

##### 源字符串必须以 '\0' 结束。

##### ⽬标空间必须有足够的大，能容纳下源字符串的内容。

##### 目标空间必须可修改。

##### 字符串串⾃己给⾃己追加？//不行，文字常量区

#### strcmp

##### 前大于后，返回值大于零
前小于后，返回值小于零
前等于后，返回值等于零

### ⻓度受限制的字符串函数介绍

#### strncpy

##### char str[100] = { 'a', 'c', 'd', 'f' };
char str1[100] = "vip";
这两种字符串初始化的结果一样，但明显第二种方便

##### 不带 ‘\0’

#### strncat

##### 带 ‘\0’

#### strncmp

##### 比较前n个

### 字符串查找

#### strchr

##### char * strchr ( const char *, int );
int：ASCII码

##### 查找字符，返回找到的第一个的地址

#### strrchr

##### 同strchr从后往前找

#### strpbrk

##### char * strpbrk ( const char * str1, const char * str2 );

##### 返回第一个字符串（str1）第一次出现在第二个字符串（str2）的字符的地址

#### strstr

##### 查找子串，有返回地址，无返回null

### ⾼级字符串查找

#### strspn

##### 这个函数返回的是str1字符串中开始部分匹配str2字符串中字符的个数

##### char strtext[] = "129th";
char cset[] = "1234567890";
前3个能匹配，返回3

#### strcspn

##### 与strspn相反，返回前不相同的个数

##### char strtext[] = "bb129th";
char cset[] = "1234567890";
前2个不能匹配，返回2

#### strtok

##### 分割字符串，源码内有一个数组
第二次使用时第一个参数传null

##### char * strtok ( char * str, const char * sep );

##### sep参数是个字符串，定义了用作分隔符的字符集合

##### 第一个参数指定一个字符串，它包含了了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。

##### strtok函数找到str中的下一个标记，并将其用 \0 结尾，返回一个指向这个标记的指针。

##### strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。

##### strtok函数的第一个参数为 NULL ，函数将在同⼀个字符串中被保存的位置开始，查找下一个标记。

##### 如果字符串中不存在更多的标记，则返回 NULL 指针。

### 错误信息报告

#### strerror

##### 返回错误码，所对应的错误信息。

### 字符操作

#### 以后的字符操作都调用函数，不要自己写

#### isspace： 
空格 ‘ ’换页 ‘\f’ 换行‘\n’回车‘\r’制表符‘\t‘或垂直制表符’\v’ 返回真

#### isdigit：
十进制数字

##### isdigit（‘2’）//返回真

#### islower ：
转小写

#### isupper：
转大写

### 内存操作函数

#### 都是按字节拷贝

#### memcpy

##### void * memmove ( void * destination, const void * source, size_t num );
如果source和destination有任何的重叠，复制的结果都是未定义的。

#### memmove

##### 解决memcpy重叠问题

#### memset

##### 都用零

#### memcmp

##### 比较

#### memchr

##### 查找

## 自定义类型

### 结构体

#### 结构体类型的声明

##### 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

##### 声明：
struct tag
{
member-list;
}variable-list;

###### 这里，tag标签可以省略，但是这样声明的两个结构体是不同类型

###### 元素用“；“分隔

###### 结束也用”；“分隔

#### 结构的成员

##### 结构的成员可以是标量、数组、指针，甚⾄至是其他结构体。

##### 成员的访问

###### .操作
s.name

###### ->操作
当时结构体指针时，不用(*p).name这么繁琐
p->name即可

#### 结构的自引用

##### 不能直接引用自己，可以引用自己的指针

#### 结构的不完整声明

##### 不完整声明结构体的互相引用，需要在前面进行声明

#### 结构体变量的定义和初始化

##### struct Point
{
int x;
int y;
}p1; //声明类型的同时定义变量p1
struct Point p2; //定义结构体变量p2

##### struct Point p3 = {x, y};
struct Stu //类型声明
{
char name[15];//名字
int age; //年龄
};
struct Stu s = {"zhangsan", 20};//初始化

#### 结构体内存对齐规则

##### 第一个成员在与结构体变量偏移量为0的地址处。

##### 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数 = 编译器默认的一个对齐数 与 该成员⼤小的较小值。 VS中默认的值为8 Linux中的默认值为4

##### 结构体总⼤小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍。

##### 如果嵌套了结构体的情况，嵌套的结构体对齐到⾃己的最大对齐数的整数倍处，结构体的整体⼤小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

##### 为什么要内存对齐

###### 平台原因(移植原因)：

####### 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

###### 性能原因：

####### 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

###### 结构体的内存对齐是拿空间来换取时间的做法。

###### 所以经量让占用空间小的成员集中在一起

#### 修改系统默认对齐数

##### # pragma pack(x)//不能超过系统默认对齐数

#### 结构体传参

##### 传指针，如果直接传结构体名字，相当于传了整个结构体（栈桢结构内存是有限的），浪费空间和性能

#### 结构体实现位段（位段的填充&可移植性）

##### struct A
{
int _a:2;
int _b:5;
int _c:10;
int _d:30;
};

###### 0.用”：“分隔

###### 1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型

###### 2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。

###### 3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

##### 跨平台问题

###### 1. int位段被当成有符号数还是无符号数是不确定的。

###### 2. 位段中最大位的数⽬不能确定。（16位机器器最⼤大16，
32位机器器最⼤大32，写成27，在16位机器器会出问题。）

###### 3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。

###### 4. 当一个结构包含两个位段，第二个位段成员⽐较大，⽆法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。

##### 网络中用得多，报头

### 枚举enum

#### 枚举类型的定义

##### enum Day//星期
{
	Mon,
	Tues,
	Wed,
	Thur,
	Fri,
	Sat,
	Sun
};

###### {}中的叫枚举常量，默认从0开始递增，可修改

#### 枚举的优点

##### 1. 增加代码的可读性和可维护性

##### 2. 很#define定义的标识符比较枚举有类型检查，更加严谨。

##### 3. 防止了命名污染（封装）

##### 4. 便于调试

##### 5. 使用方便，一次以定义多个常量

### 联合

#### 联合类型的定义

##### union Un
{
	char c;
	int i;
};

##### 联合也是一种特殊的自定义类型；
这种类型定义的变量量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。

#### 联合的特点

##### 联合的成员是共用同一块内存空间的，这样一个联合变量的⼤小，⾄少是最大成员的⼤小（因为联合至少得有能力保存最大的那个成员）。

#### 判断大小端

##### union Un1
{
	char c;
	int i;
};
union Un1 un；
un.i = 1；
if(1 == un.c) ；//小端，
else
//大端

#### 联合大小的计算

##### 联合的⼤小至少是最⼤成员的⼤小。

##### 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。

#### IP地址用点分十进制表示

##### union ip_addr
{
	unsigned long addr;
	struct
	{
		unsigned char c1;
		unsigned char c2;
		unsigned char c3;
		unsigned char c4;
	}ip;
};
int main ()
{
	union ip_addr my_ip;
	my_ip.addr = 176238749;
	printf("%d.%d.%d.%d\n", my_ip.ip.c4, my_ip.ip.c3, 	my_ip.ip.c2, my_ip.ip.c1);
	return 0;
]

## 动态内存管理

### 为什么存在动态内存分配

#### 有时候我们需要的空间⼤小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足。

### 在堆上开辟空间

### 动态内存函数的介绍

#### malloc

##### void* malloc (size_t size);

###### 开辟好返回指针，失败返回NULL，所以开辟完一定记得判空

###### 类型是void*，由自己决定

####### ptr = (int*)malloc(num*sizeof(int));

#### calloc

##### void* calloc (size_t num, size_t size);

###### 函数的功能是为 num 个⼤小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0（与malloc的区别之处）。

#### realloc

##### void* realloc (void* ptr, size_t size);

###### realloc函数的出现让动态内存管理理更加灵活。可以调整已申请内存大小

###### ptr 是要调整的内存地址

###### size 调整之后新⼤小

###### 返回值为调整之后的内存起始位置。

###### 这个函数调整原内存空间⼤小的基础上，还会将原来内存中的数据移动到新的空间。

###### realloc在调整内存空间的是存在两种情况：

####### 情况1：原有空间之后有足够⼤的空间
直接追加

####### 情况2：原有空间之后没有足够大的空间
重新开辟

#### free

##### void free (void* ptr);

##### free(ptr);
ptr = NULL;

##### 一定记得释放，指针置零（好习惯）

### 常见的动态内存错误

#### 不判空

#### 不free()

#### free()非动态开辟的内存

#### 多次free()

### ⼏个经典的笔试题

### 柔性数组

#### C99 中，结构中的最后一个元素允许是未知⼤小的数组，这就叫做『柔性数组』成员

#### 不计入结构体的大小

#### 特点

##### 结构中的柔性数组成员前面必须⾄至少一个其他成员。

##### sizeof 返回的这种结构⼤⼩不包括柔性数组的内存。

##### 包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期⼤小。

#### 好处

##### 方便释放内存（普通方法，需要开辟两次才能实现，一次开辟一个结构体指针，一次开辟空间）

##### 提高访问速度，减少内存碎片

## 输入/输出函数

### 错误报告函数

#### void perror ( const char * str );

##### 里面可以写内容，内容+错误码对应信息，也可不写，不写就直接打印错误码对应信息

### 终止执行

#### void exit (int status);

##### EXIT_SUCCESS //0） 和 EXIT_FAILURE//(1) 来表示成功或者失败返回。

##### exit(1);

### I/O概念

#### 文本流

#### 二进制流

#### 对于每一个ANSI C程序⽽言，⾄少打开三个流：标准输⼊（stdin）、标准输出（stdout）、标准错误（stderr），他们都是一个指向FILE结构的指针。

#### I/O常量量

##### EOF -文件结束标志，表示文件到了结尾

##### FOPEN_MAX - ⼀个程序最多打开文件数。

##### FILENAME_MAX - 文件名的最⼤长度。

### I/O函数总览

#### 字符输入函数	getchar		标准输入流

#### 字符输出函数	putchar 	标准输出流

#### 字符输入函数	fgetc, getc	 所有输入流

#### 字符输出函数	fputc, putc	 所有输出流

#### ⽂本行输入函数		fgets, gets	 所有输入流

#### ⽂本行输出函数f	puts, puts		 所有输出流

#### 格式化输⼊函数		scanf	 标准输入流

#### 格式化输出函数		printf	 标准输出流

#### 格式化输入函数		fscanf	 所有输入流

#### 格式化输出函数		fprintf	 所有输出流

#### 二进制输⼊	fread	 文件

#### 二进制输出	fwrite 	文件

### 打开流

#### FILE * fopen ( const char * filename, const char * mode );

##### r 读
w 写
a 追加
r+读更新
w+写更新
a+ 追加跟新
b 二进制
t 文本

### 关闭流

#### int fclose ( FILE * stream );

### 字符I/O

#### getchar 和 putchar函数

#### getc和putc函数

#### fgetc和fputc函数

### 未格式化的行I/O

#### gets和puts函数

##### char * gets ( char * str );

##### int puts ( const char * str );

#### fgets和fputs

##### char * fgets ( char * str, int num, FILE * stream );

##### int fputs ( const char * str, FILE * stream );

### 格式化的行I/O

#### scanf和printf

##### int scanf ( const char * format, ... );

##### int printf ( const char * format, ... );

#### fscanf和fprintf

##### int fscanf ( FILE * stream, const char * format, ... );

##### int fprintf ( FILE * stream, const char * format, ... );

### 二进制I/O

#### size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );

#### size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream )

### 其他函数介绍

#### fflush

#### ftell

#### fseek

#### setbuf

#### setvbuf

#### rewind

#### fgetpos

#### fsetpos

#### feof

#### ferror

#### clearerr

#### tmpfile

#### remove

#### rename
